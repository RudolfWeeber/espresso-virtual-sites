/** \mainpage

\section introduction Introduction

tcl_md is a MPI parallel molecular dynamics program. It uses a
<a href="http://tcl.activestate.com">Tcl</a> script for
controlling details of the simulation to allow great flexibility.
The standard Tcl language was extended by some commands which allow
to perform a complete MD simulation. Details on the additional Tcl commands
can be found \ref tcl "here".

The script is interpreted on only one node,
the master node. The other nodes wait for the master node to issue
specific actions, i. e. we utilize a client-server model. More details
can be found in \ref communication.h "communication.h". During the
actual integration however the communication is done synchronous.
For details see \ref integrate.c "integrate.c".

\section start Getting Started

<ol>
<li> Get your PEP membership.
<li> Add the following lines to your .cshrc file.
\verbatim 
##################################################################
# Settings for TCL_MD
##################################################################
if ( (`uname` == "Linux") ) then
    setenv PATH "${PATH}:.:/opt/lam/bin"
endif
# cvs root directory 
setenv CVSROOT ~pep/cvsroot
# TCL_MD source directory
setenv TCLMD_SOURCE  "your_directory/tcl_md"
# TCL_MD script directory
setenv TCLMD_SCRIPTS "your_directory/tcl_md/scripts"
\endverbatim
Replace your_directory by the directory where you want to install tcl_md.
<li> Get your local copy with:
\verbatim cvs checkout tcl_md \endverbatim
<li> Compile using 
\verbatim gmake \endverbatim
<li> Create actual documentation with (html, latex, man and rtf). This 
command works only on our Linux PCs (needs doxygen).
\verbatim gmake doc\endverbatim
(Use touch somefile.c if it does not work rightaway)
<li> Read the documentation carefully (Come on, there had been only 213 pages when I
was writing these lines) !!!
<li> Try the sample script files in testsuite directory: 
setup.tcl which sets up a new configuration using the ramp potential.
test.tcl Doing some MD on the new configuration. Try also the VMD
connection included (set use_imd y).
<li> Complain if you experience problems.
</ol>

\section restrictions Restrictions

<ul>
<li> The long range part is implemented for full periodicity, cubic
box and cubic mesh only. The program will probably crash if you mix up 
things here.
</ul>

\section bugs Bugs

No bugs known at the moment.

\section help More help about ...

<ul>
<li> \ref tcl
<li> \ref our_cvs
<li> \ref our_doxygen
<li> \ref blockformat
<li> \ref libtcl_md
</ul>

*/

/** \page tcl Using the Tcl Extension

The program tcl_md is an enhanced Tcl interpreter. Additionally to the standard commands
of Tcl it offers the following commands, which are implemented in C and provide the
interface between the Tcl script and the MD code:

<ul>
    <li>\anchor tcl_setmd \verbatim setmd <variable> <value>+ \endverbatim
	modifies variables declared in \ref #fields. More information can be
	found in \ref variables_page. The C implementation is \ref #setmd.
	Using \verbatim [setmd <variable>] \endverbatim gives the
	actual value of <variable> in the MD code back to the Tcl script.

<li>\anchor tcl_part
	\verbatim part <particle_number> ( pos|type|q|v|f|[un]fix|ext_force|bond| [delete] <value>+ )* \endverbatim
	modifies particle data, namely position, type (monomer, ion, ...),
		    charge, velocity, force and bonds. 
	Multiple properties can be changed at once. If you add a new
        particle the position has to be set first because of the spatial
        decomposition. <BR>
	Syntax for the different properties:
	<ul>
	<li> \verbatim pos <x value> <y value> <z value> \endverbatim
	<li> \verbatim type <particle_type_number> \endverbatim
	Restrictions: <particle_type_number> >= 0.<BR>
	The <particle_type_number> is used in \ref tcl_inter to define the
        parameters of the non bonded interactions between different kinds
        of particles.
	<li> \verbatim q <charge> \endverbatim
	<li> \verbatim v <x value> <y value> <z value> \endverbatim
	<li> \verbatim f <x value> <y value> <z value> \endverbatim
	<li> \verbatim fix \endverbatim
	Fixes the particle in space (Needs \ref EXTERNAL_FORCES in \ref config.h).
        <li> \verbatim ext_force <x value> <y value> <z value> \endverbatim
	An additional exxternal force is applied to the particle
	(Needs \ref EXTERNAL_FORCES in \ref config.h).
        <li> \verbatim unfix \endverbatim
	Release any external influence from the particle 
	(Needs \ref EXTERNAL_FORCES in \ref config.h).
	<li> \verbatim bond <bond_type_number> <partner>+ \endverbatim
	Restrictions: <bond_type_number> >= 0; partner must be an existing particle.<BR>
	The <bond_type_number> is used for \ref tcl_inter to define bonded interactions.
	<li> \verbatim bond delete <bond_type_number> <partner>+ \endverbatim
	Searches for the given bond and deletes it.
	<li> \verbatim bond delete\endverbatim
	will delete all bonds attached to this particle.
	</ul>

	\anchor tcl_part_delete
	If instead of a property "delete" is given, the particle is deleted and all
	bonds referencing it.
        \anchor tcl_part_print
        If instead of a property "print" is given,
	\verbatim part <particle_number> print (id|pos|type|q|v|f|fix|ext_force|bond)* \endverbatim
	writes out the given properties in a simple list form like
        \verbatim 40 8.849 1.8172 1.4677 1.0 {} \endverbatim
	generated by
	\verbatim part 40 print id pos q bonds\endverbatim
	This routine is primarily meant for effective use in Tcl scripts
	(see e. g. \ref tcl_blockfile_write_particles).
	If no property is given, 
	\verbatim part <particle_number> \endverbatim 
	returns all properties of the particle, if it exists, in the form
	\verbatim 0 pos 2.1 6.4 3.1 type 0 q -1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0 bonds { {0 480} {0 368} ... } \endverbatim
	which may be used as an input to this function later on. The first integer is the
	particle number. <BR>
	\verbatim part deleteall \endverbatim
	deletes <i>all<i> particles in the simulation.
	Without any parameters at all,
	\verbatim part \endverbatim
	returns the properties of <i>all</i> stored particles in a 
	tcl-list with the same format as specified above:
	\verbatim {0 pos 2.1 6.4 3.1 type 0 q -1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0 bonds { {0 480} {0 368} ... }} 
 {1 pos 1.0 2.0 3.0 type 0 q 1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0 bonds { {0 340} {0 83} ... }} 
 {2...{{...}...}} {3...{{...}...}} ... {...{{...}...}}\endverbatim
        The C implementation is \ref #part. <BR>

<li> \anchor tcl_inter \verbatim inter ( <particle_type_number1> <particle_type_number2> | <bond_type_number> ) <interaction_type> <value>+ \endverbatim
	sets the parameters for interactions.

	<ol>
	<b><li> \anchor tcl_non_bonded Non bonded interactions:</b> 
	\verbatim inter <particle_type_number1> <particle_type_number2> <interaction_type> <value>+ \endverbatim	
	Non bonded interaction between particles of types
	<particle_type_number1> and <particle_type_number2>
	(the types are those set using \ref tcl_part).<BR>
	Currently known <interaction_type>s are:

	<ul>
	   	<li>\verbatim lennard-jones <epsilon> <sigma> <cutoff> <shift> <offset> \endverbatim
			the known Lennard-Jones potential
			\f[4 \epsilon \left(\left(\frac{\sigma}{r-offset}\right)^{12} -
				 \left(\frac{\sigma}{r-offset}\right)^6 + shift\right)\f]
			The order of the parameters is
			\f$\epsilon, \sigma, cutoff, shift, offset\f$.

		<li>\verbatim ramp <cutoff> <force_magnitude> \endverbatim
			a simple step potential for initialization.<BR>
			The parameters are the cutoff and the force
			magnitude. If two particles are within the
			cutoff, they feel a constant repulsion of the
			given magnitude.
	</ul>
	If no <interaction_type> is given,
	\verbatim inter <particle_type_number1> <particle_type_number2> \endverbatim
	returns the parameters of the currently active potentials for
	non-bonded interactions in the format
	\verbatim 0 1 lennard-jones 1.0 2.0 1.1225 0.0 0.0 \endverbatim
	which corresponds to the input-format of \ref tcl_inter.
	Again the first two integers are <particle_type_number1> and <particle_type_number2>.

	<b> <li> \anchor tcl_bonded Bonded interactions: </b>
	\verbatim inter <bond_type_number> <interaction_type>|num <value>* \endverbatim
	Bonded interaction (bonds are set using \ref tcl_part).
	If "num" is given, the number of interaction partners is given (e.g. 1 for FENE).
	Currently known <interaction_type>s are:

	<ul>
		<li> \verbatim fene <K_fene> <R_fene> \endverbatim
			FENE potential
			\f[ U^{FENE} = -\frac{1}{2} K_{FENE} R_{FENE}^2 \ln
			\left( 1 - \left( \frac{r}{R_{FENE}} \right)^2 \right) \f]
		<li> \verbatim angle <bend> \endverbatim
			cosine bend potential  
			\f[ U^{bend} = bend (1-\cos(\alpha))
			\f]
			with \f$ \alpha \f$ being the angle between two
			neighboring bonds.
	</ul>
	If no <interaction_type> is given,
	\verbatim inter <bond_type_number> \endverbatim
	returns the parameters of the potential responsible for the
	bonded interactions of bonds with that <bond_type_number> in the format
	\verbatim 0 FENE 7.0 2.0 \endverbatim	
	which again directly corresponds to the input-format of the respective
	interaction with the first integer being <bond_type_number>.

	<b> <li> \anchor tcl_coulomb Coulomb interaction: </b>
        \verbatim inter	coulomb <bjerrum-length> <method> [parameters] \endverbatim

	Implemented Methods are: 

	<ul>
		<li> \verbatim p3m <r_cut> <mesh> <cao> <alpha> \endverbatim
		or
		\verbatim p3m tune accuracy <value> [r_cut <value> mesh <value> cao <value>] \endverbatim	
		This is an implemantation of the 1/r Coulomb potential
		\f[ U^{C-P3M} = \ell_B T \frac{q_1 q_2}{r} \f]
		with help of the P3M Method described elsewhere. 

		Make sure you know how to tune p3m parameters befor
		using the automatic tuning feature. Details are
		described in the documentation of \ref
		P3M_tune_parameters.

		Some additional p3m parameters have preset values:
		\verbatim epsilon = 0.0 \endverbatim 
		The dielectric constant of the surrounding medium.
		\verbatim n_interpol = 32768 \endverbatim 
		Number of interpolation points for the charge assignment function.
		\verbatim mesh_off = 0.5 0.5 0.5 \endverbatim 
		Offset of the first mesh point from the lower left corner of the simulation box
		in units of the mesh constan.
		As soon as p3m is turned on the additional parameters can be changed with:
		\verbatim inter coulomb <parameter-name> <value(s)>  \endverbatim

		<b> Make sure that you know the relevance of the P3M Parameters befor using P3M !!!</b>

		<li> \verbatim dh <kappa> <r_cut> \endverbatim
		Debye-H{\"u}ckel potential: 
		\f[ U^{C-DH} = 	\ell_B T \frac{q_1 q_2 exp(-\kappa r)}{r} \f]
		For \f[ \kappa = 0 \f] this corresponds to the plein coulomb potential.
	</ul>		

	\verbatim inter	coulomb \endverbatim
	returns the actual parameters of the coulomb interaction.

	</ol>
	\verbatim inter \endverbatim
	returns a list of \emph{all} bonded and non-bonded interactions as a Tcl-list,
	in the same formats as above, e. g.
	\verbatim {0 0 lennard-jones 1.0 2.0 1.1225 0.0 0.0} {0 FENE 7.0 2.0} {1 angle 1.0}\endverbatim	
	The C implementation is \ref #inter.

<li>\anchor tcl_constraint
        \verbatim constraint <type_name | delete> [parameters] \endverbatim
	A constraint is a surface which interacts with all particles via a Lennard-Jones potential.
	\f[4 \epsilon \left(\left(\frac{\sigma}{r}\right)^{12} -
	\left(\frac{\sigma}{r}\right)^6 + shift\right)\f]
	with r being the distance of the center of the particle to the surface. 
	The corresponding force acts in direction of the normal vector of the surcafe.
	Possible usages are:
	\verbatim constraint wall <n_x> <n_y> <n_z> <d> <lj_eps> <lj_sig> <lj_cut> <lj_shift> \endverbatim
	The resulting surface is a plane defined by the normal vector 
	<n_x> <n_y> <n_z> and the distnace <d> from the origin
	\verbatim constraint sphere <c_x> <c_y> <c_z> <rad> <lj_eps> <lj_sig> <lj_cut> <lj_shift> \endverbatim
	The resulting surface is a sphere with center <c_x> <c_y> <c_z> 
	and radius <rad>. The force is pointing inwards.
	\verbatim constraint delete <num> \endverbatim
	Delete constraint with number <num>. 
	This may change the numbers of the other constraints. 
	The contraint numbers can be obtained with:
	\verbatim constraint \endverbatim
	Print out all constraint information.

<li>\anchor tcl_writemd
	\verbatim writemd <channel> ( posx|posy|posz|q|type|vx|vy|vz|fx|fy|fz )+\endverbatim
	writes to the channel <channel> (previously opened using the Tcl commands open or
	socket) the given properties for all particles in a binary format decribed by
	\ref binary_file.h "binary_file.h". Note that the data format is written in hardware
	dependend format. Especially files written on AIX cannot be read by Linux or Tru64
	computers. This command is only meant to be used for restart checkpoints, NOT for
	permanent data storage. The C implementation is \ref #writemd.

<li>\anchor tcl_readmd \verbatim readmd <channel>\endverbatim
	reads back data written by \ref tcl_writemd.
	The components posx, posy and posz must be included since otherwise
	domain decomposition is impossible.
	The C implementation is \ref #readmd.

<li>\anchor tcl_integrate \verbatim integrate <steps> \endverbatim
	run <steps> integration steps. 
	The C implementation is \ref #integrate.

<li>\anchor tcl_blockfile
    \verbatim blockfile <channel> read|write start|end|variable|auto|toend <param>?\endverbatim
        blockfile allows for convienent access to a block format structured file <channel>. The
	possible actions are:
<ol>
	<li>\verbatim blockfile <channel>  write start <tag> \endverbatim which writes a start "{"
	and the title of the block given by tag.
        <li>\verbatim blockfile <channel>  write end \endverbatim just writes a "}" to <channel>.
	<li>\verbatim blockfile <channel>  write variable <variablename> \endverbatim
            writes a variable <variablename>
            which is known to \ref tcl_setmd to <channel>.
	<li>\anchor tcl_blockfile_write_particles
            \verbatim blockfile <channel> write particles <what> <range>\endverbatim
    	    writes particle information in a standardized format to the file <channel>.
	    <what> can be any list of parameters that \ref tcl_part_print "part <x> print"
	    takes except for "bonds". Notice that if "id" or "pos" is missing, this is added
	    in the front to the list automatically. <range> is a Tcl list of ranges which particles
	    to write. The range "all" is valid as well as a boundary of "end". For example
	    \verbatim blockfile file10 write particles "id pos q" "all 0-end 0" \endverbatim
	    will write all particles two times to file10 and then particle 0 alone.
	<li>\anchor tcl_blockfile_write_interactions
            \verbatim blockfile <channel> write interactions\endverbatim
    	    writes interactions information in a standardized format to the file <channel>.
	<li>\anchor tcl_blockfile_write_bonds
            \verbatim blockfile <channel> write bonds <range>\endverbatim
    	    writes bonds information in a standardized format to the file <channel>. The involved
	    particles and bond types must exist and be valid.
	<li>\verbatim blockfile <channel> read start \endverbatim reads the start part of a block
            and returns the block title.
	<li>\verbatim blockfile <channel> read toend \endverbatim reads the blocks data and returns
	    it.
	<li>\verbatim blockfile <channel> read particles|interactions|bonds\endverbatim
	    reads one block, checks wether it contains data of the given type and reads it.
        <li>\verbatim blockfile <channel> read auto \endverbatim reads in one block and does the
            following:
	<ol>
            <li> if the block is a global variable, the variable is set to the value from <channel>
                 and "setvar <variablename>" is returned
            <li> if the block is a variable, it returns "uservar <variablename> <data>", where data
                 is the data block (normally _ival_ or _dval_).
	    <li> if the block is a particle block, the particles are read in. The same applies to
		 bonds and interactions blocks.
            <li> if the block has a different tag, it returns "usertag <tag> <rest of block>"
            <li> if the file is at end, it returns "eof"
	</ol>
</ol>
        If parameters different from "read|write ..." are given, a procedure "blockfile_arg1_arg2"
	is searched for and called with the same argument as blockfile. For example
	\verbatim blockfile channel write particles "id pos" all \endverbatim
	results in the evaluation of
	\verbatim blockfile_write_particles channel write particles "id pos" all \endverbatim
	while
        \verbatim blockfile <channel> read auto \endverbatim does the same by trying to call
	"blockfile_read_auto_tag" for every tag it does not recognize.

	The C implementation is \ref #blockfile.

   <li> For the time being it is NOT a wise idea to load a new configuration if there's still one within 'tcl_md': 
        Single informations such as parameters or particle positions are simply overwritten, 
	but complex ones such as bonds etc. are not replaced but rather attached - 
	this is a known drawback of 'tcl_md's storage policy and will be changed sometime later on.
</ul>

At program start, tcl_md reads in a starting script
<i>'init.tcl'</i>. It is assumed to be located in a directory
<i>"scripts"</i>, but this default value can be overridden by the
environment variable TCLMD_SCRIPTS.<BR>
It also includes some useful tcl-scripts (which should always be
located in the same directory <i>"scripts"</i>) providing additional
commands which are implemented in tcl and enhance the interface
between the tcl-script and the MD-code:

<ul>
    <li>\anchor tcl_convertDeserno2MD
	\verbatim convertDeserno2MD <source_file> <destination_file>\endverbatim
	converts the particle configuration stored in <source_file>
	from Deserno-format into blockfile-format, importing everything
	to 'tcl_md' and writing it to <destination_file>. 
	The full particle information, bonds, interactions, and parameters will be converted and saved.<BR>
	If <destination_file> is "-1", the data is only loaded into 'tcl_md' and nothing is written to disk.<BR>
	If <destination_file> has the suffix '.gz', the output-file will be compressed.<BR>
	The script uses some assumptions, e.g. on the
	<particle_type_number>s of \ref tcl_part for polymers,
	counter-ions, or on <i>sigma, shift, offset</i> for
	Lennard-Jones-potentials (\ref tcl_inter; current defaults are 
	2.0, 0, 0, respectively); these are all set by
	\verbatim initConversion \endverbatim
	(which is automatically called by <i>convertDeserno2MD</i>)
	so have a look at the sourcecode of
	<i>'convertDeserno.tcl'</i> in the <i>"scripts"</i>-directory for a
	complete list of assumptions.<BR>
	However, if for some reasons different values need to be set,
	it is possible to bypass the initialization routine and/or
	override the default values, e.g. by explicitly executing
	<i>initConversion</i>, afterwards overwriting all variables
	which need to be re-set, and manually invoking the main
	conversion script
	\verbatim convertDeserno2MDmain <source_file> <destination_file> \endverbatim
	to complete the process.

    <li>\anchor tcl_convertMD2Deserno
	\verbatim convertMD2Deserno <source_file> <destination_file>\endverbatim
	converts the particle configuration stored in the 'tcl_md'-blockfile <source_file> into a
	Deserno-compatible <destination_file>.<BR>
	If <source_file> is "-1", the data is entirely taken from 'tcl_md' without loading anything from disk.<BR>
	If <source_file> has the suffix '.gz', it is assumed to be compressed; otherwise it will be treated as containing plain text.<BR>
	Since Deserno stores much more than 'tcl_md' does due to a
	centralized vs. a local storage policy, it depends on correct
	values for the following properties, which therefore should be contained in <source_file>:
	<ol>
	<li> the <particle_type_number> used for polymers,
	counter-ions, and salt-molecules (defaults are: 
	<i>set type_P 0</i>, <i>set type_CI 1</i>, and <i>set type_S 2</i>
	<li> the <bond_type_number> used for FENE-interactions
	(default is: <i>set type_FENE 0</i>)
	</ol>
	As for <i>convertDeserno2MD</i>, the defaults are set upon
	initialization by
	\verbatim initConversion \endverbatim
	(which is automatically called by <i>convertMD2Deserno</i> as well),
	but may be overwritten the same way as explained for \ref
	tcl_convertDeserno2MD. However, parameters stored in <source_file> cannot (and will not) be overwritten,
	because they were part of the system originally saved and should not be altered initially.<BR>
	Note, that some entries in a Deserno-file cannot be determined 
	at all, these are by default set to
	\verbatim set prefix AA0000
 set postfix 0
 set seed -1
 set startTime -1
 set endTime -1
 set integrationSteps -1
 set saveResults -1
 set saveConfig -1
 set subbox_1D -1
 set ip -1
 set step -1 \endverbatim
	but of course may be overwritten as well after calling
	<i>initConversion</i> and before continuing with
	\verbatim convertMD2DesernoMain <source_file> <destination_file>\endverbatim
	the actual conversion process.<BR>
	The Deserno-format assumes knowledge of the topology, hence a respective analysis is conducted 
	to identify the type and structure of the polymer network.
	The script allows for randomly stored polymer solutions and
	melts, no matter how they're messed up; however, crosslinked
	networks need to be aligned to be recognized correctly, i.e.
	they must be set up consecutively, such that the first chain
	with $MPC monomers corresponds to the first $MPC particles in
	[part], the 2nd one to the $MPC following particles, etc. etc.

   <li> For the time being it is NOT a wise idea to load a new configuration if there's still one within 'tcl_md': 
        Single informations such as parameters or particle positions are simply overwritten, 
	but complex ones such as bonds etc. are not replaced but rather attached - 
	this is a known drawback of 'tcl_md's storage policy and will be changed sometime later on.
   <li> It is now possible to save the <i>whole</i> state of 'tcl_md', including all parameters and interactions. 
        These scripts make use of that advantage by storing everything they find in the Deserno-file - but vice versa they also expect 
	you to provide a blockfile containing all possible informations.
   <li> Earlier versions of 'convertDeserno.tcl' used the binary-format of \ref tcl_writemd and \ref tcl_readmd to save 'tcl_md'-configurations.
        Since we switched permanently to the blockfile-format, if you urgently need the binary format, 
	please contact me, and I will gladly provide you with the corresponding version v1.4 of 'convertDeserno.tcl'.
</ul>
These conversion scripts have been tested with both polymer melts and
end-to-end-crosslinked networks in systems with or without
counterions. It should work with additional salt-molecules or neutral
networks as well, although that hasn't been tested yet - if you've
some of these systems in a Deserno-formated file, please submit them
for extensive analysis.
<ul>
    <li>\anchor tcl_polyBlockWrite
	\verbatim polyBlockWrite <path> <param_list> <part_list>\endverbatim
	writes out the current 'tcl_md' configuration as an Axa-blockfile, including parameters, interactions, particles, and bonds.<BR>
	<path> should contain the filename including the full path to it.<BR>
	<param_list> gives a tcl-list of the 'tcl_md'-parameters (out of node_grid | box_l | niatypes | time_step | skin | gamma | bjerrum | p3m_alpha | p3m_r_cut | p3m_mesh | p3m_cao | p3m_epsilon | p3m_mesh_offset | max_num_cells | periodicity) to be saved; if an empty list '{}' is supplied, no parameters are written. Defaults to the full parameter set.<BR>
	<part_list> gives a string of the particle-properties (out of pos | type | q | v | f) to be saved to disk; if an empty string ' "" 'is provided, no particles, no bonds, and no interactions are written. Defaults (if omitted) to all particle-properties.<BR>
	Depending on the file-name's suffix, the output will be compressed (if <path> ends with '.gz'), too.<BR>
	Note, that 'polyBlockWrite' in combination with \ref tcl_convertMD2Deserno replaces the (undocumented) function 'polywr': 
	To save the current configuration to a Deserno-compatible file (e.g. for use with 'poly2pdb') you may now use \ref tcl_polyBlockWrite
	to save your current configuration to a blockfile, and convert that with \ref tcl_convertMD2Deserno afterwards,
	or you directly write a Deserno-compatible file by invoking
	\verbatim convertMD2Deserno "-1" <output-filename>\endverbatim
	out of 'tcl_md' to save your current active configuration.

    <li>\anchor tcl_countBonds
	\verbatim countBonds <particle_list>\endverbatim
	returns a tcl-list of the <i> complete </i> topology described by
	<particle_list>, which must have the same format as [part] (see 
	\ref tcl_part).<BR>
	The output list contains only particle_number and the
	corresponding bonding informations, thus it looks like e.g.
	\verbatim {106 {0 107}} {107 {0 106} {0 108}} {108 {0 107} {0 109}} ... {210 {0 209} {0 211}} {211 {0 210}} 212 213 ... \endverbatim
	for a single chain of 106 monomers between particle 106 and
	211, with additional loose particles 212, 213, ... (e.g. counter-ions). <BR>
	Note, that \ref tcl_part stores any bonds only with the
	particle of <i>lower</i> particle number, which is why [part 109] 
	would only return {... bonds {{0 110}}}, therefore not
	revealing the bond between particle 109 and (the preceding)
	particle 108, while <i>countBonds</i> would return <i>all</i>
	bonds particle 109 participates in.

    <li>\anchor tcl_findPropPos
	\verbatim findPropPos <particle_property_list> <property>\endverbatim
	returns the index of <property> within
	<particle_property_list>, which is expected to have the same
	format as [part <particle_number>]. If <property> is not
	found, -1 is returned.<BR>
	This function is useful to access certain properties of
	particles without hard-wiring their index-position, which
	might (again) change in future releases of \ref #part.
	\verbatim [lindex [part $i] [findPropPos [part $i] type]]\endverbatim
	for example returns the <particle_type> of particle $i without fixing
	where exactly that information has to be in the output of
	[part $i].
    <li>\anchor tcl_findBondPos
	\verbatim findBondPos <particle_property_list>\endverbatim
	returns the index of the bonds within
	<particle_property_list>, which is expected to have the same
	format as [part <particle_number>];<BR>
	hence its output is the	same as [findPropPos <particle_property_list> bonds].
	If the particle does not have any bonds, -1 is returned.

    <li>\anchor tcl_timeStamp
	\verbatim timeStamp <path> <prefix> <postfix> <suffix>\endverbatim
	modifies the filename contained within <path> to be preceded by
	a <prefix> and having a <postfix> before the <suffix>; e.g.
	\verbatim timeStamp ./scripts/config.gz DH863 001 gz\endverbatim
	returns './scripts/DH863_config001.gz'.<BR>
	If <postfix> is '-1' the current date is used in the format
	'\%y\%m\%d' thus leading to './scripts/DH863_config021022.gz' on
	October 22nd, 2002.
</ul>
*/

/** \page our_cvs How to use CVS

<b>Befor checking in any changes you should make sure that</b>
<ol>
<li> your file contains no conflicts with the cvs version.
<li> the code compiles without warning on Linux and OSF1.
<li> the not yet written maketest "test procedure" runs. 
<li> you have informed the responsible person of that file about major
changes.
</ol>

Here a list of the most common cvs commands we need:

<ul>
<li> \anchor cvs_add \verbatim cvs add <file> \endverbatim
	Adds <file> to the cvsroot directory. You have to use 
	\ref cvs_commit "commit" to make your add complete. 
<li> \anchor cvs_checkout \verbatim cvs checkout <project> \endverbatim
	This will create a new directory <project> in the CWD, containing an
	up-to-date version of <project>.
<li> \anchor cvs_commit \verbatim cvs commit <file> \endverbatim
	Puts your changes into the cvsroot directory and makes them
	available for the others. 
	<b>Use with care and write a senseful comment!!!</b>
<li> \anchor cvs_diff \verbatim cvs diff <file> \endverbatim
	Shows differences of your local copy of <file> with respect
	to the cvs version.	
<li> \anchor cvs_log \verbatim cvs log <file> \endverbatim
	Shows the log file for <file>, e.g. comments on changes that
	have been made in the past and who is responsible for them.
<li> \anchor cvs_remove \verbatim cvs remove <file> \endverbatim
	removes a file from the cvsroot directory. That means, it is
	still there and can be restored, but will not be contained in
	future checkouts and updates. <b>Use with care!!!</b><BR>
	For permanent deletion use \ref cvs_commit "commit" one final
	time on that file, adding e.g. 'removed.' as comment. <b>Use
	with even more care!!!</b>
<li> \anchor cvs_status \verbatim cvs status <file> \endverbatim
	Reports the status of your local copy of <file> with respect
	to the cvs version.	
<li> \anchor cvs_update \verbatim cvs update \endverbatim
	Get the current version of all files from the cvsroot
	directory. There will be a U in front of files that are
	updated, a M before files where cvs merges your local copy
	with the cvs version and a ? if there are files in your local
	directory which are not known to cvs. You will get a warning 
	\verbatim conflicts during merge \endverbatim for files where
	cvs is not able to merge. <b>You have to look at these files
	by hand!</b> They contain sections like
	\verbatim 
<<<<<<< init.tcl
Local version of the file (e.g. 'init.tcl')
as stored in your local directory
=======
CVS version of the file (e.g. release 1.5)
from the repository in the cvsroot directory
>>>>>>> 1.5
	\endverbatim
	You have to <b>think first</b> and then decide how to combine
	the two versions.
</ul>

For more help on CVS, see 
<a href="http://www.mpip-mainz.mpg.de/www/theory/computers/pdsoftie/doc/cvs/cvs_toc.html">CVS Manual</a>
*/

/** \page our_doxygen How to do the documentation (Doxygen)

The documentation for tcl_md is mainly contained in the source code
and is automatically generated using doxygen.
<p>
For each modul the documentation of the user interface, this are
public funtions and external variable, should be in the header
file. All other documentation should be in the c-file.
<p>
The documentation for each function should contain a short
description, if necessary a more detailed description and a
description for the return value and parameters.
<p>
Look at the documentation of existing files and functions to get a
feeling how it should be!
<p>
Doxygen is able to understand simple LaTex and HTML commands as well
as some special command in order to give the documentation a nice
structure and to make it more readable. In the following list you find 
a short description of the most common commands we need:

<ul>
<li> \anchor doc_anchor   \verbatim \anchor <name> <description>\endverbatim
	Set an anchor to which you can refer using \ref doc_ref "\ref"
<li> \anchor doc_href     \verbatim <a href="http://www.your_url.html"> name </a>\endverbatim
	Link to an external html source.
<li> \anchor doc_file     \verbatim \file <name> <description>\endverbatim
	Special anchor for a file (see \ref doc_anchor "\anchor").
<li> \anchor doc_image    \verbatim \image html  doc/figs/fig.gif \endverbatim
                          \verbatim \image latex doc/figs/fig.eps \endverbatim
	Include a picture. You have to put both lines in the
	documentation since HTML and LaTex need different file formats.
<li> \anchor doc_list     \verbatim 
<ul>
<li> List entry
</ul>
\endverbatim
	Creates a list in the documentation (For example the list you
	are reading at the moment).
<li> \anchor doc_name     \verbatim 
/** \name <group_name> <short description>.
    <long_description>
*/
/*@{*/ 
<group members>
...
/*@}*/ 
\endverbatim
	Introduces a group to which one can refer with 
	\ref doc_ref "\ref". The documentation of the group members
	must be inside the \@{ ... \@} comments.
<li> \anchor doc_param    \verbatim \param <parameter> <description> \endverbatim
	Documentation for a parameter of a function
<li> \anchor doc_ref      \verbatim \ref <name> ["<text>"] \endverbatim
	Inserts a link to the documentation of <name>.
<li> \anchor doc_return   \verbatim \return <description>\endverbatim
	Documentation for the return value of a function
<li> \anchor doc_todo     \verbatim \todo <task to be done> \endverbatim
	Starts a paragraph where a TODO item is described. The
	description will also add an item to a separate TODO list. The
	two instances of the description will be
	cross-referenced. Each item in the TODO list will be preceded
	by a header that indicates the origin of the item. The TODO
	list can be found under [Related Pages] 
</ul>

*/
