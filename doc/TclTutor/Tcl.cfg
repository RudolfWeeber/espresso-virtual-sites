;# NAME:   Tcl.cfg
;# AUTHOR: Clif Flynt
;# DATE:   Apr 24, 2000
;# DESC:   The configuration for Tcl lessons.
;#
;# PARAMETERS:  
;#
;# RCSID: $Header$
;#
;# This code copyright 2000 to Clif Flynt
;# 9300 Fleming Rd
;# Dexter, MI  48130
;# clif@cflynt.com
;# All Rights Reserved.
;#
;# Release: 2.0 beta4

#
# Parse the error in result/errorInfo, and find appropriate lines in
#   text.
# Return list of start/end indices for BAD tag.
#
proc ParseError {text cmdline result errorInfo} {
  global Tutor

  Debug "-----------------------"
  Debug "TEXT: $text"
  Debug "CMD: $cmdline"
  Debug "RESULT: $result"
  Debug "ERRIN: $errorInfo"

  set errlst [split $errorInfo "\n"]
  
  set start 0.0

  Debug "ERRLST: $errlst"
  
  set first 999999;
  set firstcmd ""

  foreach cmd [list {"while" body}  {"foreach" body} {"for" body} \
        {"if" then} {"if" else} {"switch"} {procedure \"} ] {
     set pos [lsearch $errlst "*($cmd*"]
     Debug "POSCHK: $pos $cmd "
     #
     # OK, the bug is in some sort of a "body".  Find the body, and
     #  use that as an anchor for earliest place the error can be.
     #
     if {($pos >= 0) && ($pos < $first)} {
         
	 # If it's a procedure, we need to mung matters a bit, the procedure
	 #  error message is different from the other "body" parts.

         if {[string first "procedure" $cmd] == 0} {

             # This is for pre 8.2 interps, to catch bogus {procedure "puts"} 
  	     #  flags, when the error is in puts, not in the procedure.

	     if {[string first {procedure "puts"} [lindex $errlst $pos]] >= 0} {
	         break;
	     }
	     set f [lindex $errlst $pos]
	     regexp {procedure "([^"]+)"} $f m1 procName
             Debug "PROCNAME: $procName"
	     set firstcmd $procName
         } else {
         set firstcmd [string trim [lindex $cmd 0] {"}]
	 }
         set firststr $cmd
	 set first $pos
     }
     
  }
  
  Debug "FIRSTCMD: $firstcmd"
  
  # If we had some sort of body part, firstcmd will be it. 
  #  Grab that part of the error messages, parse out the 'line X' info
  #  find the body part, and add the line number to define our start
  #  of search.  This is probably the trouble line, but we'll go through
  #  the rest of the search anyhow.
  
  if {![string match $firstcmd ""]} {
      set linpos [lindex [split [string trim [lindex $errlst $first] ")("]] end]
      incr linpos -1
      set pos [lsearch $errlst "\"$firstcmd*"]
      Debug "P3: $pos"
      if {$pos >= 0} {

         if {[string first "procedure" $firststr] == 0} {
	     set f [lindex $errlst $pos]
	     regexp {procedure "([^"]+)"} $f m1 procName
	     set str "proc $procName"
	 } else {
             set str [string trim [lindex $errlst $pos] {". }]
	 }
         set pos [$Tutor(text.code) search $str $start end]
	 Debug "START: $start POS: $pos STR: ..$str.."
	 if {[string first "else" $firststr] >= 0} {
	     set pos [$Tutor(text.code) search else $pos end]
	 }

	 # If we fail something is weird, but we may as well punt.

	 if {$pos == ""} {set pos 0.0}	
	 foreach {sl sc} [split $pos "."] {};
	 incr sl $linpos
	 set start "$sl.0"
      }
  }

  Debug "START: $start :: $cmdline"
  
  #  No body part, or other start marker.  we punt and use the cmdline to
  #  mark a start search location.

  if {[string match $start "0.0"] } {
     set st [string first [string trim $cmdline] $text]
     if {$st < 0} {
       Debug "FAILED TO FIND THIS CMDLINE: $cmdline"
       Debug "TEXT: $text"
     }
    set start 0.0+${st}char
  } else {
     set st $start
  }
  
  # See if we can find a string in the error list that matches a line in
  #  our text window that also comes after the known start-of-trouble.

  foreach l $errlst {
    set l [string trim $l {"}]
    set l [string trim $l]
    Debug "TP: [$Tutor(text.code) search $l $start end ] :: $l :: $st :: $start"
    if {[set pos [$Tutor(text.code) search $l $start end ]] != ""} {
        set st2 [string first $l $text]
        Debug "ST: $st ST2: $st2"
	if {$st2 >= $st} {
          set len [string length $l]
          Debug "POS1: $pos: $l"
	  foreach {l c} [split $pos "."] {}
	  return "$pos $l.[expr $c+$len]"
	}
    }
  }


  return [list "0.0+${st}char" "0.0+[expr $st + [string length $cmdline]]char"]
}

