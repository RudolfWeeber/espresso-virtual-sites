/** \page tcl_t_random The t_random command
    \verbatim t_random [{ int <n> | seed [<seed(0)> ... <seed(n_nodes-1)>] | stat [status-list] }] \endverbatim
    <ul>
	<li> Without further arguments,\verbatim t_random\endverbatim returns a random double between 0 and 1
	     using the 'ran1' random number generator from <i>Numerical Recipes</i>.
	<li> \verbatim t_random int <n>\endverbatim returns a random integer between 0 and n-1.
	<li> \verbatim t_random seed \endverbatim returns a tcl-list with the seeds of the random number generators
	     on each of the 'n_nodes' nodes, while
	     \verbatim t_random seed <seed(0)> ... <seed(n_nodes-1)> \endverbatim
	     sets those seeds to the new values respectively, re-initialising the random number generators on each node.<BR>
	     Note that this is automatically done on invoking <i>Espresso</i>, however due to that  your simulation will always start
	     with the same random sequence on any node unless you use this tcl-command to reset the sequences' seeds.
	<li> Since internally the random number generators' random sequences are not based on mere seeds but rather on whole random
	     number tables, to recover the exact state of the random number generators at a given time during the simulation run (e. g.
	     for saving a checkpoint) requires knowledge of all these values. They can be accessed by
	     \verbatim t_random stat \endverbatim
	     which returns a tcl-list with all status informations for any node (e. g. 8 nodes => approx. 350 parameters). To overwrite 
	     those internally in <i>Espresso</i> (e. g. upon restoring a checkpoint) submit the whole list back using
	     \verbatim t_random stat <status-list> \endverbatim
	     with <status-list> being the tcl-list mentioned above without any braces.<BR>
	     <b>Be careful!</b> A <i>complete</i> recovery of the current state of the simulation is only possible if you make sure to
	     include a call to \ref tcl_invalidate_system <i>after</i> you saved the checkpoint (\ref tcl_checkpoint_set will do this
	     automatically for you), because the integration algorithm re-uses the old forces calculated in the previous time-step; 
	     if something has changed in the system (or if it has just been read from a file) the forces are re-derived (including application 
	     of the thermostat and its random numbers) leading to slightly different results compared to the uninterrupted run (see
	     \ref tcl_invalidate_system for details)!
    </ul>
    The C implementation is \ref #t_random.
*/
/** \page tcl_bit_random The bit_random command
    \verbatim bit_random [{ seed [<seed(0)> ... <seed(n_nodes-1)>] | stat [status-list] }] \endverbatim
    <ul>
	<li> Without further arguments,\verbatim bit_random\endverbatim returns a random double between 0 and 1
	     using the R250 generator XOR-ing a table of 250 linear independent integers.
	<li> \verbatim bit_random seed \endverbatim returns a tcl-list with the seeds of the random number generators
	     on each of the 'n_nodes' nodes, while
	     \verbatim bit_random seed <seed(0)> ... <seed(n_nodes-1)> \endverbatim
	     sets those seeds to the new values respectively, re-initialising the random number generators on each node.<BR>
	     Note that this is automatically done on invoking <i>Espresso</i>, however due to that your simulation will always start
	     with the same random sequence on any node unless you use this tcl-command to reset the sequences' seeds.
	<li> Since internally the random number generators' random sequences are not based on mere seeds but an array of 250 linear 
	     independent integers whose bits are used as matrix elements which are XOR-ed, to recover the exact state of the random 
	     number generators at a given time during the simulation run (e. g. for saving a checkpoint) requires knowledge of <i>all</i> 
	     these values. They can be accessed by
	     \verbatim bit_random stat \endverbatim
	     which returns a tcl-list with all status informations for any node (e. g. 8 nodes => approx. 2016 parameters). To overwrite 
	     those internally in <i>Espresso</i> (e. g. upon restoring a checkpoint) submit the whole list back using
	     \verbatim bit_random stat <status-list> \endverbatim
	     with <status-list> being the tcl-list mentioned above without any braces.<BR>
	     <b>Be careful!</b> A <i>complete</i> recovery of the current state of the simulation is only possible if you make sure to
	     include a call to \ref tcl_invalidate_system <i>after</i> you saved the checkpoint (\ref tcl_checkpoint_set will do this
	     automatically for you), because the integration algorithm re-uses the old forces calculated in the previous time-step; 
	     if something has changed in the system (or if it has just been read from a file) the forces are re-derived (including application 
	     of the thermostat and its random numbers) leading to slightly different results compared to the uninterrupted run (see
	     \ref tcl_invalidate_system for details)!
	 <li>Note further that the bit-wise display of integers, as it is used by this random number generator, is platform dependent.
	     As long as you stay on the same architecture this doesn't matter at all; however, it wouldn't be wise to use a checkpoint
	     including the state of the R250 to restart the simulation on a different platform - most likely, the integers will have a
	     different bit-muster leading to a completely different random matrix.<BR>
	     So, if you're using this random number generator, <i>always remain on the same platform</i>!
    </ul>
    The C implementation is \ref #bit_random.
*/
