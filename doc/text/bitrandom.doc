/** \page tcl_bit_random The bit_random command
    \verbatim bit_random [{ seed [<seed(0)> ... <seed(n_nodes-1)>] | stat [status-list] }] \endverbatim
    <ul>
	<li> Without further arguments,\verbatim bit_random\endverbatim returns a random double between 0 and 1
	     using the R250 generator XOR-ing a table of 250 linear independent integers.
	<li> \verbatim bit_random seed \endverbatim returns a tcl-list with the seeds of the random number generators
	     on each of the 'n_nodes' nodes, while
	     \verbatim bit_random seed <seed(0)> ... <seed(n_nodes-1)> \endverbatim
	     sets those seeds to the new values respectively, re-initialising the random number generators on each node.<BR>
	     Note that this is automatically done on invoking <i>Espresso</i>, however due to that  your simulation will always start
	     with the same random sequence on any node unless you use this tcl-command to reset the sequences' seeds.
	<li> Since internally the random number generators' random sequences are not based on mere seeds but an array of 250 linear 
	     independent integers whose bits are used as matrix elements which are XOR-ed, to recover the exact state of the random 
	     number generators at a given time during the simulation run (e.g. for saving a checkpoint) requires knowledge of <i>all</i> 
	     these values. They can be accessed by
	     \verbatim bit_random stat \endverbatim
	     which returns a tcl-list with all status informations for any node (e.g. 8 nodes => approx. 2016 parameters). To overwrite 
	     those internally in <i>Espresso</i> (e.g. upon restoring a checkpoint) submit the whole list back using
	     \verbatim bit_random stat <status-list> \endverbatim
	     with <status-list> being the tcl-list mentioned above without any braces.<BR>
	     <b>Be careful!</b> A <i>complete</i> recovery of the current state of the simulation is only possible if you are saving/restoring 
	     the checkpoint while all particles' forces are set to zero or on/after a change in the particles' configuration!
	     This is because the integration algorithm re-uses the old forces calculated in the previous time-step; if something has changed 
	     in the system (or if it has just been read from a file) the forces are re-derived (including application of the thermostat and
	     its random numbers) leading to slightly different results compared to the uninterrupted run!
    </ul>
    The C implementation is \ref #t_random.
*/
