/** \page tcl_analyze The analyze command
    \verbatim analyze <what> [<structure info>] [...] \endverbatim
    This command provides online-calculation of local and global observables.<BR>
    Without any further information the following are accessible:
    <ul>
    <li> \verbatim analyze mindist \endverbatim
         returns the minimal distance between two particles in the system.
    <li> \verbatim analyze nbhood { <part_id> | <posx> <posy> <posz> } <r_catch> \endverbatim
         returns all particles within a given radius <r_catch> around the position of the particle with number <part_id>
	 or around (<posx>, <posy>, <posz>).
    <li> \verbatim analyze distto { <part_id> | <posx> <posy> <posz> } \endverbatim
         returns the minimal distance of all particles to coordinates (<posx>, <posy>, <posz>) or to the position of particle <part_id>.
    <li> \verbatim analyze energy [{ fene <type_num> | lj <type1> <type2> | coulomb | kinetic }] \endverbatim
         returns the energies of the system. The output corresponds to the  blockfile format (\ref blockformat):
	 { energy <value> } { kinetic <value> } { interaction <value> } ... <BR>
	 If you specify <interaction>, e.g. <i>fene <type_num></i> or <i>lj <type1> <type2></i> or <i>coulomb</i> or <i>kinetic</i>,
	 it returns just that energy.
    <li> \verbatim analyze distribution { <part_type_list_a> } { <part_type_list_b> } [<r_min> <r_max> <r_bins> <log_flag> <int_flag>] \endverbatim
         returns its parameters and the distance distribution of
         particles with types specified in <part_type_list_a> (group a)
         around particles with types specified in <part_type_list_b>
         (group b) with distances between <r_min> and <r_max>, binned into
         <r_bins> bins. The bins are either equidistant (<log_flag>=0) or
         logarytmically equidistant (<log_flag>=1). If an integrated
         distribution is required use <int_flag>=1. The distance is
         defined as the minimal distance between a particle of group a
         to any of group b. The output corresponds to the blockfile
         format (\ref blockformat): <br>
	 { parameters } { { <r-value> <distribution-value> } ... }
    <li> \verbatim analyze rdf { <part_type_list_a> } { <part_type_list_b> } [<r_min> <r_max> <r_bins>] \endverbatim
         returns its parameters and the radial distribution function (rdf) of
         particles with types specified in <part_type_list_a> (group a)
         around particles with types specified in <part_type_list_b>
         (group b). The range is given by <r_min> and <r_max> and is
         divided into <r_bins> equidistant bins. The output
         corresponds to the blockfile format (\ref blockformat): <br>
	 { parameters } { { <r-value> <rdf-value> } ... }
    <li> \verbatim analyze pressure [{ total[s] | ideal | fene [<type_num>] | harmonic [<type_num>] | lj [<type1> [<type2>]] | coulomb }]\endverbatim
         derives the <i>pressure</i> and all its contributions in the system. Return value is a tcl-list looking like
	 \verbatim 0.002753 0.000008 { ideal 0.002000 } { { FENE -0.006172 0.000038 } }  { lj 0.005996 0.000023 } { coulomb 0.000930 0.000001 }\endverbatim
	 specifying the pressure, its square, the ideal gas pressure, the contributions from bonded interactions, the contributions from 
	 non-bonded interactions, the electrostatic contributions. If only certain contributions are desired, the additional options may be used
	 to access those; in that case only a two-value tcl-list is returned (e.g. <tt>-0.006172 0.000038</tt> for <tt>analyze pressure fene</tt> 
	 in the above example), consisting of the requested contribution and its square (except for <tt>analyze pressure total</tt> 
	 which only returns the pressure, while <tt>analyze pressure totals</tt> returns both, e.g. <tt>0.002753 0.000008</tt> in the above example).
	 If the <type_num> are given as well, only the contributions of interactions with that specific <type_num> are considered, returning e.g.
	 <tt>0.006136 0.000023</tt> for <tt>analyze pressure lj 0</tt> and <tt>-0.006172 0.000038</tt> for <tt>analyze pressure fene 0</tt>.
    <li> \verbatim analyze set <structure info> \endverbatim
         defines the structure of the current system. The second argument defines the topology to set, i. e. 'chains' at the moment.
	 <ul>
	 Possible values for <structure info> are
	 <li> \verbatim analyze set chains [<chain_start> <n_chains> <chain_length>] \endverbatim
              A set of <n_chains> chains of equal length <chain_length> which start with the particle with particle number <chain_start>
	      and are consecutively numbered (i.e. last particle in that topology has number <chain_start> + <n_chains>*<chain_length>). 
	      If no parameters are given, the ones currently stored are returned.
	 </ul>
    </ul>
    All tasks below need <n_chains>*<chain_length> particles to be stored consecutively starting with identity <chain_start>, representing
    <n_chains> chains of <chain_length> monomers each. This structure-info has to be set either by
	\verbatim analyze set chains <chain_start> <n_chains> <chain_length> \endverbatim
    or to be provided upon calling (which (re-)sets the structure info permanently, i.e. is only required once):
    <ul>
    <li> \verbatim analyze { re | <re> } [<chain_start> <n_chains> <chain_length>] \endverbatim
         returns the root of the quadratic end-to-end-distance averaged over all polymers (requires chain structure to be set or provided).<BR>
	 If '<re>' is given instead of 're', the derivation uses all configurations which have been previously specified with 'analyze append',
	 hence taking a time-average as well. Note that the stored configurations are assumed to be equidistant in time (i.e. you have to call
	 'analyze append' in equidistant intervalls), and that no changes in the particle setup must have been made in between (i.e. no call to
	 \ref tcl_part).
    <li> \verbatim analyze { rg | <rg> } [<chain_start> <n_chains> <chain_length>] \endverbatim
         returns the radius of gyration averaged over all chains (requires chain structure to be set or provided).
	 If '<rg>' is given instead of 'rg', the derivation uses all configurations which have been previously specified with 'analyze append',
	 hence taking a time-average as well. Note that the stored configurations are assumed to be equidistant in time (i.e. you have to call
	 'analyze append' in equidistant intervalls), and that no changes in the particle setup must have been made in between (i.e. no call to
	 \ref tcl_part).
    <li> \verbatim analyze { rh | <rh> } [<chain_start> <n_chains> <chain_length>] \endverbatim
         returns the hydrodynamic radius (requires chain structure to be set or provided).
	 If '<rh>' is given instead of 'rh', the derivation uses all configurations which have been previously specified with 'analyze append',
	 hence taking a time-average as well. Note that the stored configurations are assumed to be equidistant in time (i.e. you have to call
	 'analyze append' in equidistant intervalls), and that changes in the particle setup must not have been made in between (i.e. no call to
	 \ref tcl_part).
    <li> \verbatim analyze g123 [-init] [<chain_start> <n_chains> <chain_length>] \endverbatim
         returns the mean-square displacement <i>g1(t)</i> of a monomer,
                 the mean-square displacement <i>g2(t)</i> in the center of gravity of the chain itself, and
                 the motion of the center of mass <i>g3(t)</i>
	 as a tcl-list {g1(t) g2(t) g3(t)} (requires chain structure to be set or provided).<BR>
	 If before the structure info you give '-init', the current configuration is stored as reference config.
    <li> \verbatim analyze { <g1> | <g2> | <g3> } [<chain_start> <n_chains> <chain_length>] \endverbatim
         returns, depending on which flag has been specified, the mean-square displacement <g1(t)> of a monomer, 
	 the mean-square displacement <g2(t)> in the center of gravity of the chain itself, <b>or</b> the motion of 
	 the center of mass <g3(t)> as a tcl-list '<tt>gi(0*dt) gi(1*dt) ... gi((n_configs-1)*dt)</tt>' where i=1,2,3 is the
	 chosen observable, <tt>dt</tt> is the timestep (which must not have been changed), and <tt>n_configs</tt> is the number of
	 configurations stored by 'analyze append' which are used to derive the observable.<BR>
	 Again, note that the stored configurations are assumed to be equidistant in time (i.e. you have to call 'analyze append' 
	 in equidistant intervalls), and that changes in the particle setup must not have been made in between (i.e. no call to
	 \ref tcl_part).
    </ul>
    Some observables (i.e. non-static ones) require knowledge of the particles' positions at more than one or two times. Hence it is
    possible to store the currently active configuration 'partCfg' to the array 'configs' for later analysis. Using these mechanisms
    the program is also able to work quasi-offline by successively reading in previously saved checkpoints (see \ref blockformat) and
    appending these to 'configs', performing any analysis desired afterwards.
    <ul>
    <li> For manipulating the particles' configurations stored in 'configs' the following commands are provided:
    <ul> <li> \anchor analyze_append
              \verbatim analyze append \endverbatim
              appends the current positions of the particles in 'partCfg' to 'configs[n_configs-1]', returning an updated 'n_configs'
	      (= number of stored configurations)
	 <li> \verbatim analyze push [<size>] \endverbatim
	      adds the current configuration at the end of 'configs' and removes its very first (=oldest) entry.<BR>
	      If <size> is specified, configurations are merely appended until 'n_configs' equals <size>; from there they are pushed
	      such that 'configs' always contains the <size> most recently stored configurations (this implies that if 'analyze push <size>'
	      is called while <i>n_configs > size</i>, all <i>n_configs - size</i> uppermost (=oldest) configurations are removed to
	      end up with <size> recent entries).<BR>
	      The return value is 'n_configs'.
	 <li> \verbatim analyze replace <index> \endverbatim
              replaces the <index>th entry in 'configs' with the current configuration in 'partCfg' and returns an updated 'n_configs'
         <li> \verbatim analyze remove [<index>] \endverbatim
              removes the <index>th entry from 'configs' and returns an updated 'n_configs'. If no <index> is given, everything is removed.
         <li> \verbatim analyze configs [<config>] \endverbatim
	      returns all configuration currently stored in 'configs' as a tcl-list '{x1 y1 z1 ... xN yN zN} ... {...}'. 
	      If <config> is given, it is expected to be such a configuration covering all particles, and it is appended to 'configs'
	      (similar to <tt>analyze append</tt> but without taking the <i>current</i> configuration but <config>).<BR>
	      This command is mainly needed for setting/restoring checkpoints, i.e. to do some off-line analysis one can simply load the 
	      very last checkpoint of the simulation run by using \ref tcl_blockfile (if it was written including a call to 
	      <tt>blockfile $out write configs</tt>) - then everything is restored to 'configs', and all the <tt>analyze</tt> function
	      are available!
         <li> \verbatim analyze stored \endverbatim
              returns 'n_configs', the number of currently stored particles' configurations
         </ul>
    </ul>
    The C implementation is \ref #analyze.
*/
