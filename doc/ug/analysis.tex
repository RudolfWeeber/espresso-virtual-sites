\chapter{Analysis}
\label{chap:analysis}



\tclcommand{analyze}{%
  \var{what} 
  [\var{structure\_info}]
  [...]
}

This command provides online-calculation of local and global observables.
Without any further information the following are accessible:

\begin{tclcode}
 analyze mindist [<type_list_a> <type_list_b>]
\end{tclcode}
returns the minimal distance between two particles in the system. If the type-lists are given, then the minimal distance between particles of only those types is determined. The C implementation is mindist; it is parsed by parse\_mindist.
\begin{tclcode}
 analyze nbhood { <part_id> | <posx> <posy> <posz> } <r_catch> 
\end{tclcode}
returns all particles within a given radius \var{r\_catch} around the position of the particle with number \var{part\_id} or around the spatial coordinate (\var{posx}, \var{posy}, \var{posz}). The C implementation is nbhood; it is parsed by parse\_nbhood.

\begin{tclcode}
 analyze distto { <part_id> | <posx> <posy> <posz> } 
\end{tclcode}
returns the minimal distance of all particles to coordinates (\var{posx}, \var{posy}, \var{posz}) or to the position of particle \var{part\_id}. The C implementation is distto; it is parsed by parse\_distto.

\begin{tclcode}
 analyze distribution { <part_type_list_a> } { <part_type_list_b> }
[<r_min> [<r_max> [<r_bins> [<log_flag> [<int_flag>]]]]] 
\end{tclcode}
returns its parameters and the distance distribution of particles with types specified in \var{part\_type\_list\_a} (group a) around particles with types specified in \var{part\_type\_list\_b} (group b) with distances between \var{r\_min} and \var{r\_max}, binned into \var{r\_bins} bins. The bins are either equidistant (\var{log\_flag}=0) or logarytmically equidistant ($\var{log\_flag} \geq 1$). If an integrated distribution is required use \var{int\_flag}=1. The distance is defined as the minimal distance between a particle of group a to any of group b. The output corresponds to the blockfile format (The structured file format):
{ parameters } { { \var{r\_value} \var{distribution\_value} } ... }
 The C implementation is calc\_part\_distribution; it is parsed by parse\_distribution.

\begin{tclcode}
 analyze rdf { <part_type_list_a> } { <part_type_list_b> }
[<r_min> <r_max> <r_bins>] 
\end{tclcode}
returns its parameters and the radial distribution function (rdf) of particles with types specified in \var{part\_type\_list\_a} (group a) around particles with types specified in \var{part\_type\_list\_b} (group b). The range is given by \var{r\_min} and \var{r\_max} and is divided into \var{r\_bins} equidistant bins. The output corresponds to the blockfile format (The structured file format):
{ parameters } { { \var{r\_value} \var{rdf\_value} } ... }
The C implementation is calc\_rdf; it is parsed by parse\_rdf.

\begin{tclcode}
 analyze structurefactor { <type> <order> } 
\end{tclcode}
returns the spherically averaged structure factor for particles of a given type \var{type}. The S(q) is calculated for all possible wave vectors, 2PI/L <= q <= 2PI/L*\var{order}. Do not chose parameter \var{order} too large, becase the number of calculations grows as $\var{order}^3$. The output corresponds to the blockfile format (The structured file format):
{ \var{q\_value} \var{S(q)\_value} } ...
The C implementation is calc\_structurefactor; it is parsed by parse\_structurefactor.

\begin{tclcode}
 analyze vanhove { <type> <rmin> <rmax> <rbins> } 
\end{tclcode}
returns the van Hove auto correlation function G(r,t) and the mean square displacement msd(t) for particles of type \var{ptype} for the configurations stored in the array configs. This tool assumes that the configurations stored with 'analyze append' (analyze\_append) are stored at equidistant time intervals. G(r,t) is calculated for each multiple of this time intervals. For each time t the distribution of particle displacements is calculated acoording to the specification given by \var{rmin}, \var{rmax} and \var{rbins}. If the particles perform a random walk ('normal diffusion process') G(r,t)/(r*r) is a gaussian distribution for all times. Deviations of this behavior hint on another diffusion process or on the fact that your system has not reached the diffusive regime. In this case it is also very questionable to calculate a diffusion constant from the mean square displacement via the Stokes-Einstein relation.
Output format:
{ msd { msd(0) msd(1) ... } }
{ vanhove { { G(0,0) G(1,0) ... } { G(0,1) G (1,1) ... } ... }	
The G(r,t) are normalized such that the integral over space always yields 1.

\begin{tclcode}
 analyze centermass { <part_type> } 
\end{tclcode}
returns the center of mass of particles of given type. The C implementation is centermass; it is parsed by parse\_centermass.

\begin{tclcode}
 analyze momentofinertiamatrix { <part_type> } 
\end{tclcode}
returns the moment of inertia matrix for particles of given type. The output is a list of all the elements of the 3x3 matrix. The C implementation is momentofinertiamatrix; it is parsed by parse\_momentofinertiamatrix.

\begin{tclcode}
 analyze aggregation [{ <dist_criteria> <s_mol_id>
   	 <f_mol_id> <min_contact> <charge_criteria>}] 
\end{tclcode}
returns the aggregate size distribution for the molecules in the molecule id range \var{s\_mol\_id} to \var{f\_mol\_id};. If any monomers in two different molecules are closer than dist\_criteria they are considered to be in the same aggregate. One can use the optional \var{min\_contact} parameter to specify a minimum number of contacts such that only molecules having at least \var{min\_contact} contacts will be considered to be in the same aggregate. The second optional parameter \var{charge\_criteria} enables one to consider aggregation state of only oppositely charged particles. The C implementation is aggregation; it is parsed by parse\_aggregation.

\begin{tclcode}
 analyze find_principal_axis { <part_type> } 
\end{tclcode}
returns the eigenvalues and eigenvectors of the moment of inertia matrix for particles of a given type. The C implementation is based on calc\_eigenvalues\_3x3 and calc\_eigenvector\_3x3; it is parsed by parse\_find\_principal\_axis.
\begin{tclcode}
 analyze necklace <pearl_treshold> <back_dist> <space_dist>
<first> <length> 
\end{tclcode}
Algoritm for identifying pearl necklace structures for polyelectrolytes in poor solvent. For more information see: Limbach H.J. and Holm C. Single-Chain Properties of Polyelectrolytes in Poor Solvent J. Phys. Chem. B, 107 (32), 8041 -8055, AUG 14 2003. The first three parameters are tune parameters for the algorithm: pearl\_treshold is the minimal number of monomers in a pearl. back\_dist is the number of monomers along the chain backbone which are excluded from the space distance criterion to form clusters. space\_dist is the distance between two monomers up to which they are considered to belong to the same clusters. The three parameters may be connected by scaling arguments. Make sure that your results are only weakly dependent on the exact choice of your parameters. For the algorithm the coordinates stored in partCfg are used. The chain itself is defined by the identity first of its first monomer and the chain length length. Attention: This function is very specific to the problem and might not give useful results for other cases with similar structures.
\begin{tclcode}
 analyze holes <prob_part_type_number> <mesh_size> 
\end{tclcode}
Function for calculation of the unoccupied volume (often also called free volume) in a system. Details can be found in Schmitz, H. and Mueller-Plathe, F., J. Chem. Phys. 112, 1040-1045 (2000). Identifies free space in the simulation box via a mesh based cluster algorithm. Free space is defined via a probe particle and its interactions with other particles which have to be defined through LJ interactions with the other existing particle types via the inter command before calling this routine. A point of the mesh is counted as free space if the distance of the point is larger than LJ\_cut+LJ\_offset to any particle as defined by the LJ interaction parameters between the probe particle type and other particle types.\
How to use this function:\ Define interactions between all (or the ones you are interested in) particle types in your system and a fictious particle type. Practically one uses the van der Wals radius of the particles plus the size of the probe you want to use as the Lennard Jones cutoff. \ Define the mesh\_size. The mesh spacing is the box\_length / mesh\_size.\

Results:\
\begin{tclcode}
 { n_holes mean_hole_size max_hole_size free_volume_fraction { sizes }
{ surfaces } { element_lists } } 
\end{tclcode}
A hole is defined as a continous cluster of mesh elements that belong to the unoccupied volume. Since the function is quide rudimentary it gives back the whole information suitable for further processing on the script level. Sizes and Surfaces are given in number of mesh points, which means you have to calculate the actual size via the corresponding volume or surface elements yourself. The complete information is given in the element\_lists for each hole. The element numbers give the position of a mesh point in the linear representation of the 3D grid (coordinates are in the order x, y, z). But if you want to use the detailed information you better have a look in the source code in statistics\_cluster.c
Attention:\ Assumes cubic box.\ Surface results have not been tested. I think there is still a bug in there (Hanjo). Needs feature LENNARD\_JONES compiled in.

In energy.c:
\begin{tclcode}
 analyze energy [{ total |
 kinetic | bonded <bond_type> | nonbonded <part_type1> <part_type2>
| coulomb }]
\end{tclcode}

returns the energies of the system.

If you do not specify an argument, it returns all the contributions to the total energy in the the blockfile format

\begin{tclcode}
{ energy <value> } { kinetic <value> } { interaction <value> } ... 
\end{tclcode}
If you specify total, it returns just the total energy without giving the details on its contributors. Any other argument will return the corresponding contribution.
The C implementation is energy\_calc, which calls energy\_calc on all nodes; it is parsed by parse\_and\_print\_energy.
In pressure.c:

\begin{tclcode}
 analyze pressure [{ total[s] | ideal | 
bonded <bond_type> | nonbonded <part_type1> <part_type2>
| coulomb | tot_nonbonded_intra | tot_nonbonded_inter | 
nonbonded_intra <part_type1> | nonbonded_inter <part_type2> }] 
\end{tclcode}
derives the pressure and all its contributions in the system.

Without an argument, analyze pressure will return a tcl-list looking like
\begin{tclcode}
 0.002753 0.000008 { ideal 0.002000 } { { FENE -0.006172 0.000038 } } 
 { lj 0.005996 0.000023 } { coulomb 0.000930 0.000001 }
\end{tclcode}
specifying the pressure, its square, the ideal gas pressure, the contributions from bonded interactions, the contributions from non-bonded interactions and the electrostatic contributions.


If only a certain contribution is desired, the additional arguments may be used to access those; in that case only a two-value tcl-list is returned (e. g. -0.006172 0.000038 for analyze pressure bonded in the above example), consisting of the requested contribution and its square (except for analyze pressure total which only returns the pressure, while analyze pressure totals returns both, e. g. 0.002753 0.000008 in the above example).

Note that the ideal pressure is derived using the temperature, hence for systems with temp = 0 it will be zero; in those cases it is preferable to use analyze p\_IK1 which looks at the velocities of the particles.

This command is implemented as a parallel algorithm: The C implementation is pressure\_calc, which calls pressure\_calc on all nodes; it is parsed by parse\_and\_print\_pressure.

Todo:
 Document arguments nb\_inter, nb\_intra, tot\_nb\_inter and tot\_nb\_intra of analyze pressure. 
\begin{tclcode}
 analyze p_IK1 <bin_volume> <ind_list> <flag_all>
\end{tclcode}
derives the pressure-tensor and all its contributions in the system. Return value is a tcl-list looking like

6.918227 47.861859 { total 1.487761 -0.498393 1.105992 0.141777 1.548216 -0.219248 0.202950 -1.821126 3.882250 } { ideal -0.121384 -0.497965 0.930397 0.142206 0.187245 -0.225073 0.027355 -1.826951 2.418630 } { bonded -4.531248 -0.050332 0.281053 -0.050332 -4.291891 -0.226408 0.281053 -0.226408 -4.324098 { FENE -4.531248 -0.050332 0.281053 -0.050332 -4.291891 -0.226408 0.281053 -0.226408 -4.324098 } } { nonbonded 6.140393 0.049904 -0.105458 0.049904 5.652861 0.232232 -0.105458 0.232232 5.787717 } 

specifying the pressure, its square, its tensorial form, and the tensorial form of its components ideal, bonded, nonbonded, coulombic pressure (if applicable); the bonded component is further split up into its different contributions (FENE, ANGLE, HARMONIC) sort according to the interaction type number specified by The inter command. Note that the tensorial entries $ p^{(k,l)} $ are directly derived from

\[ p^{(k,l)} = \sum_{j>i\in {\tt bin}} F_{ij}^{(k)} \cdot r_{ij}^{(l)} \]

where e. g. $ F_{ij}^{(k)} $ denotes the kth entry of the difference vector between the force vectors of particles i and j, while the ideal pressure is determined from the particles' velocities, i.e.

\[ p^{(k,l)}_{\tt ideal} = \sum_{i\in {\tt bin}} v_{i}^{(k)} \cdot v_{i}^{(l)} \]

contrary to analyze pressure ideal which uses the temperature. In both cases, the sum is taken over only those particles whose identities have been provided in \var{ind\_list} if \var{flag\_all}=0, otherwise i loops over \var{ind\_list} while j represents all particles in the system. Since this command is intended to follow the Kirkwood-scheme IK1, all particles given in \var{ind\_list} should represent a bin geometry with volume \var{bin\_volume} for the algorithm to make sense, although this is not checked; hence it is preferable to obtain \var{ind\_list} from analyze bins.

This command is executed on the master node only, hence a higher number of nodes only slows it down due to the increasing amount of communication processes required between the nodes to gather all needed particle informations. Furthermore, all interactions including electrostatic ones are treated with the virial ansatz given above, which makes non-periodic systems highly recommendable, and which slows electrostatic systems down due to the long-range interactions.

The C implementation is calc\_p\_tensor; it is parsed by parse\_and\_print\_p\_IK1. 

\begin{tclcode}
 analyze set <structure info> 
\end{tclcode}
defines the structure of the current system. The second argument defines the topology to set, i. e. 'chains' at the moment.

Possible values for \var{structure\_info} are
\begin{tclcode}
 analyze set chains [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
A set of \var{n\_chains} chains of equal length \var{chain\_length} which start with the particle with particle number \var{chain\_start} and are consecutively numbered (i.e. last particle in that topology has number \var{chain\_start} + \var{n\_chains}*\var{chain\_length}). If no parameters are given, the ones currently stored are returned.
The C implementation is parse\_chain\_structure\_info for setting, print\_chain\_structure\_info for returning the current topological informations; these functions reside in statistics\_chain.c.

UPDATE DOCUMENTATION for SET\_TOPOLOGY....

In statistics\_chain.c:
All tasks below need \var{n\_chains}*\var{chain\_length} particles to be stored consecutively starting with identity \var{chain\_start}, representing \var{n\_chains} chains of \var{chain\_length} monomers each. This structure-info has to be set either by
\begin{tclcode}
 analyze set chains <chain_start> <n_chains> <chain_length> 
\end{tclcode}
or to be provided upon calling (which (re-)sets the structure info permanently, i.e. is only required once):
\begin{tclcode}
 analyze { re | <re> } [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
returns the quadratic end-to-end-distance and its root averaged over all polymers (requires chain structure to be set or provided) as a tcl-list comprising of re error\_of\_re re2 erro\_of\_re2.
If '\var{re}' is given instead of 're', the derivation uses all configurations which have been previously specified with 'analyze append', hence taking a time-average as well. Note that the stored configurations are assumed to be equidistant in time (i.e. you have to call 'analyze append' in equidistant intervalls), and that no changes in the particle setup must have been made in between (i.e. no call to The part command).

The C implementation is calc\_re and calc\_re\_av, respectively; both are parsed by parse\_re.

\begin{tclcode}
 analyze { rg | <rg> } [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
returns the radius of gyration averaged over all chains (requires chain structure to be set or provided) as a tcl-list comprising of rg error\_of\_rg rg2 error\_of\_rg2.
If '\var{rg}' is given instead of 'rg', the derivation uses all configurations which have been previously specified with 'analyze append', hence taking a time-average as well. Note that the stored configurations are assumed to be equidistant in time (i.e. you have to call 'analyze append' in equidistant intervalls), and that no changes in the particle setup must have been made in between (i.e. no call to The part command).

The C implementation is calc\_rg and calc\_rg\_av, respectively; both are parsed by parse\_rg.

\begin{tclcode}
 analyze { rh | <rh> } [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
returns the hydrodynamic radius and its error as a tcl-list (requires chain structure to be set or provided). If '\var{rh}' is given instead of 'rh', the derivation uses all configurations which have been previously specified with 'analyze append', hence taking a time-average as well. Note that the stored configurations are assumed to be equidistant in time (i.e. you have to call 'analyze append' in equidistant intervalls), and that changes in the particle setup must not have been made in between (i.e. no call to The part command).

The C implementation is calc\_rh and calc\_rh\_av, respectively; both are parsed by parse\_rh.

\begin{tclcode}
 analyze { internal_dist | <internal_dist> } [<chain_start>
 <n_chains> <chain_length>] 
\end{tclcode}
returns the internal distances within the \var{n\_chains} polymer chains as a tcl-list 'idf(0) idf(1) ... idf(chain\_length-1)' where the index corresponds to the distance between the two monomers considered (1 = next neighbours, 2 = one monomer in between,...). The values are averaged over all chains, if '\var{internal\_dist}' is used averaged over all n\_config appended configurations as well.

The C implementation is calc\_internal\_dist and calc\_internal\_dist\_av, respectively; both are parsed by parse\_intdist.

\begin{tclcode}
 analyze { bond_dist | <bond_dist> } [index <index>]
 [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
returns the internal distances within the \var{n\_chains} polymer chains as a tcl-list 'bdf(0) bdf(1) ... bdf(chain\_length-1-<index>)', but contrary to 'internal\_dist' it does not average over the whole chain, but rather takes the chain monomer at position <index> (default: 0, i.e. the first monomer on the chain) to be the reference point to which all internal distances are calculated. If '\var{bond\_dist}' is used, the values will be averaged over all n\_config appended configurations as well.

The C implementation is calc\_bond\_dist and calc\_bond\_dist\_av, respectively; both are parsed by parse\_bond\_dist.

\begin{tclcode}
 analyze { bond_l | <bond_l> } [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
returns the average bond-length within a chain, averaged over all chains in the system; hence, it gives the same result as idf(0) from the internal distances functions 'internal\_dist' and '\var{internal\_dist}'. If you want to look at only specific chains, use the optional arguments, i.e. \var{chain\_start} = 2*MPC and \var{n\_chains} = 1 to only include the third chain's monomers. If '\var{bond\_l}' is used, the value will be averaged over all n\_config appended configurations as well.

The C implementation is calc\_bond\_l and calc\_bond\_l\_av, respectively; both are parsed by parse\_bond\_l.

\begin{tclcode}
 analyze { formfactor | <formfactor> } <qmin> <qmax>
 <qbins> [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
derives the spherically averaged formfactor $ S(q) = 1/chain\_length * Sum(i,j=1..chain\_length)[sin(q*r_ij)/q*r_ij] $ of a single chain, averaged over all chain\_n\_chains currently allocated (-> chain information must be set!) for \var{qbin}+1 logarithmically spaced q-vectors \var{qmin},...,\var{qmax} where \var{qmin} must be >0 and \var{qmax} must be greater than \var{qmin}. If '\var{formfactor}' is used instead of 'formfactor', the average is taken over all n\_configs stored configurations in configs as well. It returns a tcl-list, e. g. for 'analyze \var{formfactor} 0.09 3 5'

{0.090000 92.893516} {0.181476 74.906876} {0.365927 36.951854} {0.737853 10.791177} {1.487803 2.397301} {3.000000 0.609425} 

of pairs '{q S(q)}' for q=\var{qmin},...,\var{qmax}.

The C implementation is analyze\_formfactor and analyze\_formfactor\_av, respectively; both are parsed by parse\_formfactor.

\begin{tclcode}
 analyze rdfchain { <r_min> <r_max> <r_bins> } [<chain_start>
 <n_chains> <chain_length>] 
\end{tclcode}
returns three radial distribution functions (rdf) for the set chain structure. The first rdf is calculated for monomers belonging to different chains, the second rdf is for the centers of mass of the chains and the third one is the distribution of the closest distances between the chains (i.e. the shortest monomer-monomer distances). The output is given in the blockfile format (The structured file format):
\begin{tclcode}
 { <r-value> <rdf_1-value> <rdf_2-value> <rdf_3-value>} ...
\end{tclcode}
The distance range is given by \var{r\_min} and \var{r\_max} and it is divided into \var{r\_bins} equidistant bins. The C implementation is analyze\_rdfchain; it is parsed by parse\_rdfchain.

\begin{tclcode}
 analyze g123 [-init] [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
returns the mean-square displacement g1(t) of a monomer, the mean-square displacement g2(t) in the center of gravity of the chain itself, and the motion of the center of mass g3(t) as a tcl-list {g1(t) g2(t) g3(t)} (requires chain structure to be set or provided).
If before the structure info you give '-init', the current configuration is stored as reference config.

The C implementation is calc\_g123; it is parsed by parse\_g123.

\begin{tclcode}
 analyze { <g1> | <g2> | <g3> } [<chain_start> <n_chains> <chain_length>] 
\end{tclcode}
returns, depending on which flag has been specified, the mean-square displacement \var{g1(t)} of a monomer, the mean-square displacement \var{g2(t)} in the center of gravity of the chain itself, or the motion of the center of mass \var{g3(t)} as a tcl-list 'gi(0*dt) gi(1*dt) ... gi((n\_configs - 1)*dt)' where i=1,2,3 is the chosen observable, dt is the timestep (which must not have been changed), and n\_configs is the number of configurations stored by 'analyze append' which are used to derive the observable.
Again, note that the stored configurations are assumed to be equidistant in time (i.e. you have to call 'analyze append' in equidistant intervalls), and that changes in the particle setup must not have been made in between (i.e. no call to The part command).

The C implementations are respectively calc\_g1\_av, calc\_g1\_av, and calc\_g3\_av; they are all parsed by parse\_g\_av.

In statistics.c:
Some observables (i.e. non-static ones) require knowledge of the particles' positions at more than one or two times. Hence it is possible to store the currently active configuration partCfg to the array configs for later analysis. Using these mechanisms the program is also able to work quasi-offline by successively reading in previously saved checkpoints (see The structured file format) and appending these to configs, performing any analysis desired afterwards.

For manipulating the particles' configurations stored in configs the following commands are provided:

\begin{tclcode}
 analyze append 
\end{tclcode}
appends the current positions of the particles in partCfg to configs[n\_configs - 1], returning an updated n\_configs (= number of stored configurations).

The C implementation is analyze\_append; it is parsed by parse\_append.

\begin{tclcode}
 analyze push [<size>] 
\end{tclcode}
adds the current configuration at the end of configs and removes its very first (=oldest) entry.
If \var{size} is specified, configurations are merely appended until n\_configs equals \var{size}; from there they are pushed such that configs always contains the \var{size} most recently stored configurations (this implies that if analyze push \var{size}' is called while n\_configs > \var{size}, all n\_configs-\var{size} uppermost (=oldest) configurations are removed to end up with \var{size} recent entries).
The return value is n\_configs.

The C implementation is analyze\_push; it is parsed by parse\_push.

\begin{tclcode}
 analyze replace <index> 
\end{tclcode}
replaces the \var{index}th entry in configs with the current configuration in partCfg and returns an updated n\_configs.
The C implementation is analyze\_replace; it is parsed by parse\_replace.

\begin{tclcode}
 analyze remove [<index>] 
\end{tclcode}
removes the \var{index}th entry from configs and returns an updated n\_configs. If no \var{index} is given, everything is removed.
The C implementation is analyze\_remove; it is parsed by parse\_remove.

\begin{tclcode}
 analyze configs [<config>] 
\end{tclcode}
returns all configuration currently stored in configs as a tcl-list '{x1 y1 z1 ... xN yN zN} ... {...}'. If \var{config} is given, it is expected to be such a configuration covering all particles, and it is appended to configs (similar to analyze append but without taking the current configuration but \var{config}).

This command is mainly needed for setting/restoring checkpoints, i.e. to do some off-line analysis one can simply load the very last checkpoint of the simulation run by using The blockfile command (if it was written including a call to blockfile \$out write configs) - then everything is restored to configs, and all the analyze function are available!

The C implementation is analyze\_configs; it is parsed by parse\_configs.

\begin{tclcode}
 analyze stored 
\end{tclcode}
returns n\_configs, the number of currently stored particles' configurations


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ug"
%%% End: 
