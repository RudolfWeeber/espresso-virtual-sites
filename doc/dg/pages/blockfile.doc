/** \page tcl_blockfile The blockfile command
<i>In a nutshell:</i><BR>
\ref tcl_blockfile is provided for saving and restoring the current state of Espresso,
e. g. for creating and using checkpoints. Hence you can transfer all accessible informations to and from disk from and to Espresso.
<ul>
    <li>\verbatim set out [open "|gzip -c - > checkpoint.block.gz" "w"]
 blockfile $out write variable all
 blockfile $out write interactions
 blockfile $out write random
 blockfile $out write bitrandom
 blockfile $out write particles "id pos type q v f" all
 blockfile $out write bonds all
 blockfile $out write configs
 close $out \endverbatim
        This example writes all variables accessible by \ref tcl_setmd, all interactions known to \ref tcl_inter, the full current state 
	of the random number generator (\ref tcl_t_random or \ref tcl_bit_random), all informations (i.e. id, position, type-number, 
	charge, velocity, forces, bonds) on all particles, and all particle configurations appended (using e. g. <tt>analyze append</tt>) 
	for offline-analysis purposes to the file 'checkpoint.block.gz' which is even being compressed on-the-fly (if you don't want that, 
	use '<tt>set out [open "checkpoint.block" "w"]</tt>' instead).<BR>
	Note that interactions must be stored before particles before bonding informations, as for the bonds to be set all particles and
	all interactions must already be known to Espresso.
    <li>\verbatim set in [open "|gzip -cd checkpoint.block.gz" "r"]
 while { [blockfile $in read auto] != "eof" } {}
 close $in \endverbatim
        This is basically all you need to restore the informations in the blockfile (again, if you don't have a compressed file, 
	use '<tt>set out [open "checkpoint.block" "r"]</tt>' instead) overwriting the current settings in Espresso.
</li></ul>
And now the full documentation on how \ref tcl_blockfile actually works:<BR>
    \verbatim blockfile <channel> read|write start|end|variable|auto|toend <param>?\endverbatim
        blockfile allows for convienent access to a block format structured file \<channel\>. The
	possible actions are:
<ol>
	<li>\verbatim blockfile <channel>  write start <tag> \endverbatim which writes a start "{"
	and the title of the block given by tag.
        <li>\verbatim blockfile <channel>  write end \endverbatim just writes a "}" to \<channel\>.
	<li>\verbatim blockfile <channel>  write variable {<varname1> <varname2> ...} \endverbatim
            writes the variables \<varname1\>, \<varname2\>,..., which are known to \ref tcl_setmd (a list
	    can be found in \ref variables_page), to \<channel\>.
	<li>\verbatim blockfile <channel>  write variable all\endverbatim
            will write all variables known to \ref tcl_setmd to \<channel\>.
	<li>\verbatim blockfile <channel>  write tclvariable {<varname1> <varname2> ...} \endverbatim
            writes the tcl <i>global</i> variables \<varname1\>, \<varname2\>,..., to \<channel\>. Global
	    variables are those declared in the top scope or those declared global in procedures.
	<li>\verbatim blockfile <channel>  write tclvariable all\endverbatim
            will write all global variables to \<channel\>. The predefined globals from Tcl (tcl_version, argv,
		argv0, tcl_interactive, auto_oldpath, errorCode, auto_path, errorInfo, auto_index, env,
		tcl_pkgPath, tcl_patchLevel, argc, tcl_libPath, tcl_library and tcl_platform) are omitted.
	<li>\verbatim blockfile <channel>  write tclvariable reallyall\endverbatim will even write those
	    variables, which you probably almost never want...
	<li>\anchor tcl_blockfile_write_particles
            \verbatim blockfile <channel> write particles <what> <range>\endverbatim
    	    writes particle information in a standardized format to the file \<channel\>.
	    \<what\> can be any list of parameters that \ref tcl_part_print "part <x> print"
	    takes except for "bonds". Notice that if "id" or "pos" is missing, this is added
	    in the front to the list automatically. \<range\> is a Tcl list of ranges which particles
	    to write. The range "all" is valid as well as a boundary of "end". For example
	    \verbatim blockfile file10 write particles "id pos q" "all 0-end 0" \endverbatim
	    will write all particles two times to file10 and then particle 0 alone.
	<li>\anchor tcl_blockfile_write_interactions
            \verbatim blockfile <channel> write interactions\endverbatim
    	    writes interactions information in a standardized format to the file \<channel\>.
	<li>\anchor tcl_blockfile_write_bonds
            \verbatim blockfile <channel> write bonds <range>\endverbatim
    	    writes bonds information in a standardized format to the file \<channel\>. The involved
	    particles and bond types must exist and be valid.
	<li>\anchor tcl_blockfile_write_random
	    \verbatim blockfile <channel> write random\endverbatim
	    writes the full informations on the current state of the random number generators on 
	    any node to the file \<channel\>. Using this information, it is possible to recover the 
	    exact state the generators were in at that moment.
	<li>\verbatim blockfile <channel> write seed\endverbatim
	    writes only the seed(s) which were used to initialize the random number generators.
	    Note that this information is <i>not</i> sufficient to pick up the random sequences
	    where they were left, because \ref tcl_t_random also uses a table of previous random
	    numbers to determine the next one; to also save that information use 
	    \ref tcl_blockfile_write_random.
	<li>\anchor tcl_blockfile_write_bitrandom
	    \verbatim blockfile <channel> write bitrandom\endverbatim
	    writes the full informations on the current state of the R250 random number generators on 
	    any node to the file \<channel\>. Using this information, it is possible to recover the 
	    exact state the generators were in at that moment.
	<li>\verbatim blockfile <channel> write bitseed\endverbatim
	    writes only the seed(s) which were used to initialize the bit random number generators.
	    Note that this information is <i>not</i> sufficient to pick up the random sequences
	    where they were left, because \ref tcl_bit_random uses a huge matrix of integers whose 
	    bit-patterns are XOR-ed to determine the next one; to also save that information use 
	    \ref tcl_blockfile_write_bitrandom.
	<li>\verbatim blockfile <channel> write configs\endverbatim
	    writes the complete content of the 'configs'-array in statistics.c to \<channel\>, thereby
	    saving all particle configurations appended (e. g. using <tt>analyze append</tt>) for analysis-purposes.<BR>
	    Using this offline-analysis is quite easy: Just append regularly the current configurations, include this command
	    after the derivation of the last time step, and <tt>blockfile read auto</tt> will load them later on
	    resetting 'configs' to the state needed for most of the more complex <tt>analyze</tt>-commands.
	<li>\verbatim blockfile <channel> read start \endverbatim reads the start part of a block
            and returns the block title.
	<li>\verbatim blockfile <channel> read toend \endverbatim reads the blocks data and returns
	    it.
	<li>\verbatim blockfile <channel> read particles|interactions|bonds|variable|seed|random|bitrandom|configs\endverbatim
	    reads one block, checks wether it contains data of the given type and reads it.
        <li>\verbatim blockfile <channel> read auto \endverbatim reads in one block and does the
            following:
	<ol>
            <li> if a procedure blockfile_read_auto_<tag> exists, this procedure takes over
	         (\<tag\> is the first expression in the block). For most block types, at least
		 all mentioned above, i. e. particles, interactions, bonds, seed, random, bitrandom, configs, and
		 variable, the corresponding procedure will overwrite the current information with
		 the information from the block.
            <li> if the procedure does not exist, it returns "usertag <tag> <rest of block>"
            <li> if the file is at end, it returns "eof"
	</ol>
</ol>
        If "blockfile <channel> read auto" finds a block, it tries to load the corresponding procedure
	as described above. "blockfile <channel> read <block>" checks for a block with tag \<block\>
	and then again executes the corresponding blockfile_read_auto_\<tag\>, if it exists.

	If that fails, blockfile executes "blockfile_arg1_arg2", if it exists, with the all arguments
	given to blockfile. For example
	\verbatim blockfile channel write particles "id pos" all \endverbatim
	results in the evaluation of
	\verbatim blockfile_write_particles channel write particles "id pos" all \endverbatim
	If the next block in a blockfile is a particle block, e. g.
	\verbatim
	{particles {id pos type q}
		   {0 27.251 62.31 58.707 1 1.0}
		   {1 27.226 61.483 58.146 0 0.0}
	}	
	\endverbatim
        \verbatim blockfile <channel> read auto \endverbatim will call
	\verbatim blockfile_read_auto_particles <channel> read auto\endverbatim, which then
	will delete all particles and insert the two particles above.

	In the contrary that means that for a new blocktype you will normally implement two
	procedures:
	\verbatim
	blockfile_write_<tag> {channel "write" "<tag>" param...}
	\endverbatim
	which writes the block including the header and enclosing braces and
	\verbatim
	blockfile_read_auto_<tag> {channel "read" "auto"}
	\endverbatim
	which reads the block data and the closing brace.
	The parameters "write", "read", "<tag>" and "auto" are regular parameters which will
	always have the specified value. They occur just for technical reasons.

	The C implementation is \ref #blockfile.
*/
